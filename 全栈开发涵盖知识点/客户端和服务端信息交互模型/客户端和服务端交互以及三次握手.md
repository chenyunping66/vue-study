<!--
 * @Author: your name
 * @Date: 2020-09-13 00:40:30
 * @LastEditTime: 2020-09-13 21:03:04
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \demo\全栈开发涵盖知识点\客户端和服务端信息交互模型\客户端和服务端交互的基本模型.md
-->
### 第一部分：客户端和服务端交互以及性能优化
###  客户端和服务器端
> 客户端：可以向服务器发送请求，并且接受返回的内容进行处理
> 服务器端：能够接收客户端的请求，并且把相关资源信息返回给客户端的

<!-- 1.URL地址解析
A: URI/URL/URN
-URI(Unifrom ) -->

### 1.URl地址解析
## A.URI/URL/URN
-URL(Unifrom Resoure Locator):统一资源定位符,根据这个地址能找到对应的资源
-URN(Unifrom Reasoure Name): 统一资源名称，一般指国际上通用的（标准的）一些名字（例如：国际统一发版的编号）
-URI(Unifrom Reasoure Identifier): 统一资源标识符，URL和URI的子集

### 一个完整的URL所包含的内容
>http://www.baidu.com:80/stw/index.html?from =wx&lx=1#zhenyu
-协议(http://):传输协议就是，能够把客户端和服务器端通信的信息进行传输的工具（类似于快递小哥）
   + http  超文本传输协议，除了传递文本，还可以传递媒体资源文件（或者流文件）以及XML格式数据
   + https 根据安全的http,一般需要支付的网站都要有https协议（https的s就是:ssl 加密传输）
   + ftp   文件传输协议(一般应用于把本地资源上传到服务端)
-域名(www.baidu.com):一个让用户方便记忆的名字（不通过域名，直接用服务器的外网IP也能够访问到服务器，但是外网IP很难被记住）
   + 顶级域名 qq.com(只要把顶级域名买回来，剩下的一级二级域名都是基于顶级域名可以自己分配的)
   + 一级域名 www.qq.com
   + 二级域名 sports.qq.com
   + 三级域名 kbs.sports.qq.com
   + .com 国际域名
   + .cn 中文域名
   + .com.cn
   + .edu 教育
   + .gov 政府单位
   + .io 博客
   + .org 官方组织
   + .net 系统类
   +
-端口号(:80)端口号的取值范围(0~65535),用端口号来区分同一台服务器上的不同项目
   + http默认端口号：80
   + https默认端口号：443
   + ftp默认端口号： 21
   + 如果项目采用的就是默认端口号，我们在书写地址的时候，不用加端口号，浏览器在发送请求的时候会帮我们默认加上

-请求资源路径名称(/stw/index.html) 
   +默认的路径或者名（xxx.com/stu/ 不指定资源名，服务器会找默认的资源，一般资源名是default.html、index.html...当然这些可以在服务器端自己配置）
   + 注意伪URL地址的处理（URL重写技巧是为了增加SEO搜索引擎优化的，动态的网址一般不能被搜索引擎收录，所以我们要把动态网址静态化，此时需要的是重写URL）
   https://item.jd.hk/2688449.html => https://item.jd.hk/index.php?id=2688449  (一般后台来写的)

-问号传参信息(?from =wx&lx=1)
   + 客户端想把信息传递给服务器，有很多的方式
        + URL地址问号传参
        + 请求报文传输（请求头和请求主体）
  +也可以实现不同页面之间的信息交互，例如：从列表到详情

-hash指(#zhenyu)
   + 也能够充当信息传输的方式
   + 锚点定位
   + 基于hash实现路由管控（不同的hash值，展示不同的组件和模块）

## B.特殊字符加密和解密
>请求的地址中如果出现非有效的unicode编码内容，现代版浏览器默认会进行编码：
    1. 基于encodeURI编码，我们可以基于decodeURI解码，我们一般用encodeURI编码的是整个URL,这样整个URL中的特殊字符都会自动编译
    2.encodeURIComponent/decodeURIComponent它相对于encodeURL来说，不用于给整个URL编码，而是给URL部分信息进行编辑（一般都是问号传参的值编码）
        客户端和服务端进行信息传输的时候，如果需要把请求的地址和信息编码，我们则基于以上两种方式处理，服务器也存在这些方式，这样就可以统一编码解码了
    3.客户端还存在一种方式，针对于中文的编码方式escape/unescape,这种方式一般只应用于客户端页面之间自己的处理，例如：从列表跳转到详情，我们可以把传递的中文信息基于这个编码，详情页获取编码后的信息再解码，再比如我们在客户中的cookie信息，如果信息是中文，我们也是基于这种办法编码...
    
### 2.DNA域名解析
#### DNS服务器域名解析
  > DNS服务器：域名解析服务器，在服务器上存储着 域名 <=> 对应着服务器外网IP
  > 而我们发送请求的时候所谓的DNS解析，其实就是根据域名在DNS服务器上查找到对应服务器的外网IP

A. DNS域名解些是什么？
  -发布站点时配置域名解析
  -网站访问进行DNS域名反解析

B. **DNS优化**
- DNS缓存（一般浏览器会在第一次解析后，默认建立缓存，时间很短，只有一分钟左右）
  前端性能优化之DNS预获取？DNS Prefetch 即DNS预获取
  -减少DNS的请求次数（一个网站中我们需要发送请求的域名和服务器尽可能少即可）
  -进行DNS预获取(dns-prefetch):在页面加载开始的时候，就把当前页面中需要访问其他域名(服务器)的信息进行提前DNS解析，以后加载到具体内容部分可以不用解析了

### 3.建立TCP连接（三次握手）(相当于工程队在修路)
## TCP三次握手和HTTP报文（三次挥手发生在信息传输前的）
建立TCP连接（三次握手）：（握手三次才能确保接下来信息发送确保正确，先确认连接和通信是否成功）
-第一次握手：由浏览器发起，告诉服务器我要发送请求了 （SYN=1,seq=J）
-第二次握手：由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧 (SYN=1,ACK=1,ack=J+1,seq=K)
-第三次握手：由浏览器发送，告诉服务器，我马上就发了，准备接受吧 (ACK=1,ack=K+1)

### 4.发送HTTP请求 （相当于快递员从这条路上去送东西）
A. HTTP请求报文
     -请求报文：所有经过传输协议，客户端传递给服务器的内容，都被称为请求报文
           + 起始行
           + 请求头（请求首部）(Request Headers)
           + 请求主体
     -响应报文：所有经过传输协议，服务器返回给客户端的内容，都被称为响应报文
           + HTTP状态码
           + 响应头(Response Headers)
           + 响应主体(Respone)
           Timing(响应时间)
    **-http报文：请求报文+响应报文**
=> 谷歌浏览器F12 => Network(所有客户端和服务端的交互信息在这里都可以看到) =>点击某一条信息，在右侧可以所有的HTTP报文信息

B. 强缓存和协商缓存
后续延伸了学习
-强缓存（Cache-Control 和 Expires）
-协商缓存（Last-Modifited 和 Etag）

### 7. 断开连接（四次挥手）（发生在信息传输的过程中的）
-第一次挥手：由浏览器发起，发送给服务器，我请求报文发送完了，你准备关闭吧。 （FIN_M）
-第二次挥手：由服务器发起，告诉浏览器，我接受完请求报文，我准备关闭，你也准备吧。(ack M+1)
-第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完毕，你准备关闭吧。 (FIN K+1)
-第四次挥手：由浏览器发起，告诉服务器，我响应报文接收文笔，我准备关闭，你也准备吧。 (ACK = 1 ack=K+1)

**A: Connection:Keep-Alive 保持TCP不中断（性能优化之一）
（但是堆服务器压力造成挺大的，不过可以设置长连接的时间，过了多长时间断开连接）

### 前端性能优化汇总
**1.减少http请求次数和传输报文的大小**
-文件合并压缩
-雪碧图css sprite(图片精灵)技术 *****
-使用字体图标(icon font)或者SVG等矢量图*****
   + 减少HTTP请求次数或者减少请求内容的大小
   + 渲染更快：因为他们是基于代码渲染的，而对于位图（png/jpg/gif）是需要把图片编码再渲染
   + 不容易失真变形
   + 也可以使用webp格式图片，这种格式要小一些（但是需要服务器端支持这种格式的请求处理）
- 图片懒加载（延迟加载）技术******
   + 第一次加载页面的时候不去请求真实 的图片，提高第一次渲染页面的速度
   + 当页面加载完，把出现用户视野区域中的图片做真实加载，没有出现的先不加载（节约流量，也能减少对服务器的请求压力）
   + 对于数据我们也尽可能分批加载（不要一次请求过多的技术，例如分页技术）

- 音视频文件取消预加载（preload = 'none'），这样可以增加页面第一次渲染页面的速度，当需要播放的时候再加载.*****
- 客户端和服务端的数据传输尽可能基于JSON格式完成，XML格式比JSON格式要大一些（还可以基于二进制编码或者文件流，这种格式比文件传输好很多）
- 把页面中的css/js等文件进行合并压缩******
   + 合并：争取css和js都只导入一个（webpack可以实现自动合并压缩）
   + 压缩：基于webpack可以压缩、对于图片自己找工具先压缩、还可以使用服务器的GZIP压缩
- 图片地图（对于需要多次调取使用的图片（尤其是背景图），尽可能把它提取成公共的样式，而不是每一次重新设置background(因为提取成公共的只需要加载一次))
- 图片base64(用base64码代表图片，减少HTTP请求，增加浏览器渲染的速度，所以真实项目中，尤其是移动端，如果图片加载缓慢，可能base64一下就好了，但是，base64会导致文件中的代码超级恶心，不利于维护和开发，所以少使用：webpack中可以配置图片的base64)  *****
<!-- - 对于数据我们也尽可能的分批加载，不要过多的使用，也叫数据的延迟加载 -->


**2.设置各种缓存、预处理和长连接机制（就是缓存）**
<!-- 网络缓存 -->
- 把不经常更改的静态资源做缓存处理（一般做的是304或者ETAG等协商缓存）
- DNS缓存或者预处理（DNS prefetch）,减少DNS的查找
- 建立 Cache-Control 和 Expirse HTTP 的强缓存
- 建立Connection:Keep-alive TCP长连接
- 使用HTTP2版本协议（现在用的一般都是HTTP1.1）
    + 可是多条TCP通道共存 => 管道化链接
    + 思考题：HTTP VS HTTPS
    + 思考题：HTTP1 VS HTTP2

<!-- 本地缓存 -->
- 设置本地的离线存储（Manifest）或者把一些不经常更改的数据做本地临时存储（webstorage\indexdb）等
- 有钱就做CDN（地域分布式服务器），还有一个财大气粗的方式：加服务器

- 一个项目分为不同的域（不同的服务器），例如：资源WEB服务器、数据服务器、图片服务器、视频服务器等，这样合理利用服务器资源，但是导致过多的DNS解析

**3.代码方面的性能优化**
- 减少对闭包的使用（因为过多使用闭包会产生很多不销毁的内存，处理不好的话，会导致内存溢出“栈溢出”），减少闭包的嵌套（减少作用域链的查找层级）
比如： 
```
function func() {
   func();  //Uncaught RangeError: Maximum call stack size exceeded
}
func();  //无限死循环或者死递归 => 栈溢出

// =>解决方案：异步方式setTimeout解决
function func(){
   setTimeout(func,0);  //setTimeout属于异步，等待执行，主线程继续走，过一段时间主线程闲下来继续走
}
func();  //这样就不报错

//=>相互引用:引用类型之间的相互调用，形成嵌套式内存（高程三里面讲的更好一点）
let obj1={
   name:'OBJ1',
}
let obj2={
   name:'OBJ2',
   x:obj1
}
obj1.x = obj2.x;

```
-对于动画来说：能用CSS解决的不用JS（能够用transform处理的，不用传统的css样式，因为transfrom开启硬件加速，不会引发回流。再或者使用定位的元素也会好很多，因为定位的元素脱离文档流，不会对其他元素的位置造成影响）,能用requestAnimationFrame解决的不用定时器
    +  requestAnimationFrame还有一个好处，当页面处于休眠无访问状态，动画会自己暂停，知道恢复访问才开始，而定时器是不论什么状态，只要页面不关，就一直处理着。
- 避免使用iframe(因为iframe会嵌入其他页面，这样父页面渲染的时候，还会同时把子页面也渲染了，渲染进度也会变慢)
- 减少直接对DOM的操作（原因是减少DOM的回流和重绘....）,当代项目基本上都是基于MVVM/MVC数据驱动属兔渲染的，对DOM的操作框架本身完成，性能要好很多。
- 低耦合高内聚（基于封装的方式：方法封装、插件、组件、框架、类库等封装，减少页面的冗余，提高代码使用率）
- 尽可能使用事件委托
- 避免出现死循环或者嵌套循环(嵌套循环会成倍增加循环的次数)
- 项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于promise设计模式来管理）
- JS中不要使用with
- 不要使用css表达式
- 函数的防抖和节流
- 减少使用eval(主要原因是防止压缩代码的时候，由于符号书写不合规，导致代码混乱)
- 减少filter滤镜的使用
- 尽可能减少选择器的层级(选择器是从右向左解析) .box a{} 和 a{}(这个性能更好)
- 尽可能减少table布局
- 手动回收堆栈内存（赋值为null）

前端的优化需要做的事情：
- JS前端优化的108条建议，以及雅虎的CSS代码优化的36条建议（去看看）*****
- webpack的性能优化
- 安全优化