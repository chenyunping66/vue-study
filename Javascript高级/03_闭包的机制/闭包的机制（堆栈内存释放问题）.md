### 闭包作用域
    1.创建函数
      -开辟一个堆内存
      -把函数体中的代码当作字符串存储进去
      -把堆内存的地址赋值给函数名/变量名
      -函数在哪创建的，那么它执行时所以需要查找的上级作用域就是谁****

    2.函数执行
      -形成一个全新的私有作用域，执行上下文，私有栈内存（执行一次形成一个，多个之间也不会产生影响）
      -形参赋值&变量提升
      -代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
      -遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的操作自己的变量即可，不是私有的向上级作用域中查找....一直找到全局作用域位止，这就叫做作用域链机制。 ***
      -私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是“闭包的保护机制”。***

    3.关于堆栈内存释放问题（以谷歌webkit内核为例子）
        函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不能销毁释放，很容易就会导致栈内溢出（内存爆满，电脑就卡死了），堆栈内存的释放问题就是学习JS的核心知识之一。

      1)堆内存释放问题
        堆内存是怎么形成的呢？
        -创建一个引用类型（值），就会产生一个堆内存，每个浏览器堆内存释放的问题都不一样的。
        -如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用情况，不被占用的都会自己给回收释放掉），则释放。
       ① let obj = {
          name:'cyp'
        }  //这个堆内存不会被销毁，因为被obj占用了。
      ② let oop = obj;
       //此时obj和oop都在占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联（使用=>null:空对象指针）
       obj = null;
       oop = null;

      2)栈内存释放
       栈内存是怎么形成的呢？
       -打开浏览器形成的全局全局作用域就是栈内存
       -手动执行函数形成的私有作用域就是栈内存
       -基于ES6中的let/const形成的块级作用域也是栈内存
       -....

        ·全局栈内存：只有关掉页面的时候才会销毁。
        ·私有栈内存：
            1.一般情况下，函数执行完成，形成的私有栈内存就会被销毁掉。（排除出现无限级递归和死（死循环）嵌套的模式（排除死递归的模式））
                   function fn() {
                     //...
                     fn();//死递归
                   }
                   fn(); //函数执行形成栈内存，执行完成栈内存销毁
              2.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域意外的事物占用了，则当前栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了）
              什么叫闭包？
               => 市面上认为的闭包:函数执行形成不能被释放的私有栈内存，这样的才是闭包。
              （有人认识：只要函数形成就能够形成私有变量域，就能保护里面的变量跟外面没有联系，这种保护机制，叫做闭包）
                    function x(){
                      return function(){
                       // ...
                      }
                    }
                    let f  = x(); //f占用了x形成的栈内存中的一个东西（返回小函数f对应的堆），则不能被释放了。

总结：
什么叫闭包？
               => 市面上认为的闭包:函数执行形成不能被释放（销毁）的私有栈内存，不仅保护了私有变量而且还把里面的信息保存起来了，这样的被称为闭包。
              （另外的说法：只要函数形成就能够形成私有变量域，就能保护里面的变量跟外面没有联系，这种保护机制，叫做闭包）
              （函数执行形成的私有上下文（私有的栈内存/私有作用域），保护了里面的变量和外面的变量没有联系，互不干扰，这种机制就叫闭包。）
### 闭包的两大作用
            1.保护（私有变量和外界没有必然联系）
            2.保存（形成不销毁的栈内存，里面的私有变量等信息就保存下来了）
      从性能角度讲，我们真实项目中应该减少对闭包的使用（因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者降低性能）

npm init -y
npm i jquery

node-module => jquery => dist => jqeury.js

###   ·jQuery(jq)前端非常经典的类库：提供了大量的学习方法供开发人员使用=》为了防止全局污染（解释：导入JQ后，它里面有大量的方法，如果这些方法不保护起来，用户编写的方法很容易和方法名字相同产生冲突，产生冲突可以理解为全局变量污染）JQ中的方法和变量需要用闭包保护起来。
  
  <!-- ====================JQ源码剖析=========================== -->
  
  ` //( function( global, factory ) {
     //...
     //typeof window !== "undefined" ? window : this 验证当前所处环境的全局对象是window还是global等
     <!-- 第二个函数function( window, noGlobal ) {}当作参数传入 -->
     //	factory( global ); //=>AAA(window)
   } )( typeof window !== "undefined" ? window : this, function AAA( window, noGlobal ) {} );


	var jQuery = function( selector, context ) {
        //...
  };
  //通过给全局对象增加属性：jQuery和$,把私有的jQuery方法暴露到全局作用域下，供外面使用（等同于return jQuery）(外界需要使用函数中的私有内容，我们可以基于window.xxx和return xx两种方式实现这个函数)
  	window.jQuery = window.$ = jQuery;
});

//=>开始使用JQ
jQuery();`  //window.jQuery()/$(

在真实项目中，我们一般都要把自己写的内容放到一个闭包中，这样可以有效防止自己的代码和别人的代码产生冲突（全局变量污染：真实项目中是要尽可能减少对全局变量的使用的）；如果需要把自己的东西给别人用，基于return和window.xxx等方式爆露给别人即可。

//=>源生JS
var  xxx = (function(){
  //...A自己写的代码
  return xxxx
})();

(function(){
  //...B自己写的代码
  window.xxx = xxx;
})();

=>JQ
$(function(){
  // ...这样写在某些角度上也是为了减少全局变量
});

.......

# 2.基于let/const/class等创建变量，会把所在的大括号（除对象的大括号之外）当作一个全新私有块级作用域
    -函数执行会产生私有的栈内存（作用域/上下文）
    -let等也会产生私有的块作用域（var不会）（4大区别：变量提升var有，var可以重复声明，let可以解决暂时性死区，let会产生私有的块级作用域）
```if (1===1){
  var a  = 10;
}
  console.log(a); //=>10 a是全局作用域

if(1===1){
  //=>let会有块作用域（现在大括号就是一个私有作用域）
  //=>a是私有变量
  let a  = 10;
}
console.log(a); //Uncaught ReferenceError: a is not defined  (let会有块作用域)
```

<!-- ====================================================================================================================== -->
### this
-函数执行的主体（不是上下文）：意思是谁把函数执行的，那么执行主体就是谁。
-this非常的不好理解，以后遇到this,想一句话："你以为你以为的就是你以为的"

1. 给元素的某个属性绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身

2.如何确定执行主体（this）是谁?当方法执行的时候，我们看方法前面是否有点，没有点this是window或undefined;有点，点前面是谁this就是谁;
```
  var name = 'dudj';
  function fn(){
    console.log(this);
  }
  var obj = {
    name:"你好世界",
    fn:fn
  };
  obj.fn(); //=>this:obj
  fn(); //=> *** this:非严格模式是window,严格模式下是undeined ***
  <!-- window.fn()把window.省略了 -->
```

(function(){
 //自执行函数中的this是window或者undefined
})();

思考？
第一题：
ary._proto._proto_.hasOwnProperty();
//=>hasOwnProperty方法中的this:ary._proto._proto_

第二题：
let obj = {
  fn:(function(n){
    //把自执行函数执行的返回结果赋值给fn
    //this:window 或undefined(因为自己让自己执行的)
    return function(){
      <!-- fn等于这个返回的小函数 -->
      <!-- this:指向obj ，因为前面有点obj.fn()-->
    }
  })(10)
};
obj.fn(); //fn是obj把它执行的

第三题：
function fn(){
  //this:window
  console.log(this);
}
document.body.onClick = function(){
  //this:document.body
  fn();
}
