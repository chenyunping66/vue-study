
// example 1
let a = 12;
let b= 13;
function func(){
  let a= 1;
  let b = 2;
}
func();
console.log(a,b);

// -------------------------------------------------------------------------------------------------------------

// 知识点：
// 对象数据类型：由零到多组键值对（属性名和属性值）组成的
//       属性名的类型：
//         【说法一：属性名类型只能是字符串或者Symbol】
//         【说法二：属性名类型可以是任何基本类型值，处理中可以和字符串互通，但是属性名绝对不能是引用数据类型，最后也是转换为字符串处理】

// 数组：以数字作为索引（索引就是属性名）
obj.x = function(){}
obj.x = {n:20}
obj.x = 13

// 例子1
let sy = Symbol('AA');
let x = {
  0: 0
}
let obj = {
  0:12,
  true:'xxx',
  null:20
};
obj[sy] = '加油';
obj[x] = 100; //obj['[object Object]'] = 100会把对象变成字符串作为属性名

// 例子2
for(let key in obj){
  // for in 遍历中获取的属性名都会变为字符串
  // 并且无法迭代属性名是Symbol类型的属性
  console.log(key,typeof key)
}

// 例子3
let x = 20;
let obj = {
  x: 100
};
// 属性名肯定是一个值
obj[x];  //把x变量存储的值当作属性名，获取对象的属性值 =》 obj[20] => undefined
obj['x']; //获取属性名为x的属性值 => 100   <=> 相当于 obj.x 属性名为x
// 数字的话只能中括号

// 面试题：
var a = {},
    b = '0',
    c = 0;
a[b] = '学习'; // a['0] =>'学习'
a[c] = '挣钱'; // a[0] => '挣钱'
console.log(a[b])  //挣钱

// ---------------------------------------------------------------------------------------------------------

// 作业：
var x = [1,23];
function fn(y) {
  y[0] = 100;
  y = [100];
  y[1] = 220;
  console.log(y);
}

fn(x);
console.log(x)

// var fn = xxx;
// function fn(){}
// 这两个fn都是全局变量，而且同一个变量，只是赋值不一样（function fn(){}相当于声明一个变量，变量存储的值是函数而已）

// function fn(){}
// var fn = function(){}
//两者意义是一样的，区别只是变量提升



// 创建一个函数：
  // 1.开辟一个堆内存（16进制的内存地址，AAAFFF1111）
  // 2.声明当前函数的作用域（在哪个上下文中创建的，它的作用域就指向谁）
  //2.1.顺便标记一下形参（方便我们自己后期执行的时候看看形参） 不是浏览器执行的
  // 3.把函数体中方的代码“字符串”存储在堆内存中（创建一个函数，存储的是一个对字符串，所以函数只要不执行，函数其实没啥意义）
  //4.把函数堆的地址类似于对象一样，放置在栈中供变量调用（函数名）

// 执行函数
  1.会形成一个全新的私有上下文（目的是供函数体中的代码执行），然后进栈执行
  2.在私有上下文中有一个存放私有变量的变量对象，AO(XXX)
  3.在代码执行之前要做的事情很多：
      初始化它的作用域链<自己上的上下文，函数的作用域>
      初始化this（箭头函数没有this）
      初始化arguments，实参集合（箭头函数没有arguments）
      形参赋值（形参变量是函数的私有变量，需要存储在AO中）
      变量提升（在私有上下文中声明的变量都是私有变量）
      ......
  4.代码执行(把之前在函数堆中存储的字符串，拿过来在上下文中依次执行)
    作用域链查找机制：在代码执行中，遇到一个变量，我们首先看一下是否为自己的私有变量，如果是自己的私有变量，
                     接下来所有的操作都是操作私有的（和外界没有直接的联系），如果不是自己私有的，则按照scope-chain向上级上下文中查找
                      （如果上级私有的，接下来的操作都是操作上级上下文中的变量）一直找，知道找到EC(G)为止。
  5.根据实际的情况确定当前上下文是否出栈释放
  （词法解析发生在所有的代码执行之前，全局diamagnetic执行之前）
  为了保证栈内存的大小（内存优化),一般情况下，如果当前函数执行产生的上下文，在进栈且代码执行完成后，会把这次
  上下文移除栈（上下文释放到了，之前在上下文中存储的私有的变量等信息也会跟着释放了）=》全局上下文是在打开页面生成的，
  也许要在关闭页面的时候释放掉（只有页面关闭才会被释放掉）
  有特殊情况：只要当前上下文中的某些内容，被上下文以外的东西占用，那么当前上下文是不能被释放的（上下文中存储的变量
  信息也保留下来了） =》 这种情况就是大家认为的闭包

  fn(x)
  函数第二次执行：会执行一个全新的私有上下文，把之前做过的事情，还是原封不动的再执行一次，（所有的东西都是从头来一遍的），
  此时形成的上下文和上一次形成的上下文之间没有必要的联系。
